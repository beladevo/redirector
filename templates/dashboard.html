{% extends "base.html" %}

{% block content %}
<!-- Modern Dashboard Application -->
<div x-data="dashboardApp()" x-init="initialize()" class="space-y-6">
    
    <!-- Server Status Section -->
    <section class="server-status-section" aria-label="Active Servers" data-animate>
        <div class="flex justify-between items-center mb-4">
            <h2 class="text-2xl font-bold text-gray-900">
                üñ•Ô∏è Active Redirect Servers
            </h2>
            <div class="server-header-actions">
                <div class="text-sm text-gray-600" x-show="serverStats">
                    <span x-text="serverStats?.active_servers || 0"></span> active servers
                    <span x-show="serverStats?.active_servers > 0">
                        ‚Ä¢ Avg uptime: <span x-text="serverStats?.average_uptime_formatted || 'N/A'"></span>
                    </span>
                </div>
                <button 
                    @click="refreshServers()"
                    class="btn btn-outline btn-sm"
                    title="Refresh server status"
                    :disabled="loadingServers"
                >
                    <div x-show="loadingServers" class="loading-spinner"></div>
                    <span x-show="!loadingServers">üîÑ</span>
                    <span x-text="loadingServers ? 'Loading...' : 'Refresh'"></span>
                </button>
            </div>
        </div>
        
        <!-- Server Status Cards -->
        <div class="server-status-grid" x-show="!loadingServers && servers.length > 0">
            <template x-for="server in servers" :key="server.server_id">
                <div 
                    class="server-status-card"
                    :class="{ 'active': server.is_active, 'inactive': !server.is_active }"
                >
                    <div class="server-card-header">
                        <div class="server-info">
                            <h3 class="server-id" x-text="server.server_id"></h3>
                            <div class="server-campaign">
                                Campaign: <span x-text="server.campaign"></span>
                            </div>
                        </div>
                        <div class="server-status-indicator" :class="{ 'active': server.is_active, 'inactive': !server.is_active }">
                            <span x-show="server.is_active" class="status-dot active" title="Active">‚óè</span>
                            <span x-show="!server.is_active" class="status-dot inactive" title="Inactive">‚óè</span>
                        </div>
                    </div>
                    
                    <div class="server-details">
                        <div class="server-detail-item">
                            <span class="detail-label">Host:</span>
                            <span class="detail-value" x-text="server.host"></span>
                        </div>
                        <div class="server-detail-item">
                            <span class="detail-label">Port:</span>
                            <span class="detail-value" x-text="server.redirect_port"></span>
                        </div>
                        <div class="server-detail-item">
                            <span class="detail-label">Target:</span>
                            <span class="detail-value truncate" :title="server.redirect_url" x-text="truncateText(server.redirect_url, 30)"></span>
                        </div>
                    </div>
                    
                    <div class="server-stats">
                        <div class="stat-item">
                            <div class="stat-value" x-text="formatNumber(server.total_requests)"></div>
                            <div class="stat-label">Requests</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" x-text="server.requests_per_minute"></div>
                            <div class="stat-label">RPM</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" x-text="server.avg_response_time + 'ms'"></div>
                            <div class="stat-label">Avg Time</div>
                        </div>
                    </div>
                    
                    <div class="server-uptime">
                        <div class="uptime-info">
                            <span class="uptime-label">Uptime:</span>
                            <span class="uptime-value" x-text="server.uptime_formatted"></span>
                        </div>
                        <div class="last-seen" x-show="!server.is_active">
                            Last seen: <span x-text="formatRelativeTime(server.last_seen)"></span>
                        </div>
                    </div>
                    
                    <!-- Tunnel Info -->
                    <div x-show="server.tunnel_enabled" class="server-tunnel-info">
                        <div class="tunnel-badge">
                            üåç Tunnel Enabled
                        </div>
                        <div x-show="server.tunnel_url" class="tunnel-url" x-text="server.tunnel_url"></div>
                    </div>
                    
                    <!-- Platform Info -->
                    <div class="server-platform-info">
                        <div class="platform-item" x-show="server.platform">
                            <span x-text="server.platform"></span>
                        </div>
                        <div class="platform-item" x-show="server.python_version">
                            Python <span x-text="server.python_version"></span>
                        </div>
                        <div class="platform-item" x-show="server.version">
                            v<span x-text="server.version"></span>
                        </div>
                    </div>
                </div>
            </template>
        </div>
        
        <!-- Loading State for Servers -->
        <div x-show="loadingServers" class="loading-container">
            <div class="loading-spinner"></div>
            <span>Loading servers...</span>
        </div>
        
        <!-- Empty State for Servers -->
        <div x-show="!loadingServers && servers.length === 0" class="empty-state">
            <div class="text-6xl mb-4">üñ•Ô∏è</div>
            <h3 class="text-lg font-semibold text-gray-900 mb-2">No active servers</h3>
            <p class="text-gray-600">Start a redirect server to see it here.</p>
        </div>
    </section>

    <!-- Campaign Cards Section -->
    <section class="campaign-cards-section" aria-label="Campaign Overview" data-animate>
        <div class="flex justify-between items-center mb-4">
            <h2 class="text-2xl font-bold text-gray-900">
                üìä Campaign Overview
            </h2>
            <div class="campaign-header-actions">
                <div class="text-sm text-gray-600" x-show="campaignCards.length > 0">
                    Showing <span x-text="campaignCards.length"></span> of <span x-text="campaignCardsPagination.totalItems"></span> campaigns
                </div>
                <button 
                    @click="clearAllLogs()"
                    class="btn btn-danger btn-sm"
                    title="Clear ALL logs from database"
                    data-action="clear-all"
                >
                    üóëÔ∏è Clear All Logs
                </button>
            </div>
        </div>
        
        <!-- Campaign Cards Grid -->
        <div class="campaign-cards-grid" x-show="!loadingCampaignCards && campaignCards.length > 0">
            <template x-for="card in campaignCards" :key="card.id">
                <div 
                    class="campaign-card"
                    @click="filterByCampaign(card.name)"
                    :class="{ 'active': filters.campaign === card.name }"
                    role="button"
                    tabindex="0"
                    :aria-label="`View logs for campaign ${card.name}`"
                    @keydown.enter="filterByCampaign(card.name)"
                    @keydown.space.prevent="filterByCampaign(card.name)"
                >
                    <div class="campaign-card-header">
                        <h3 class="campaign-card-title" x-text="card.name"></h3>
                        <div class="campaign-card-status" :class="{ 'active': card.is_active }">
                            <span x-show="card.is_active" class="text-green-600">‚óè</span>
                            <span x-show="!card.is_active" class="text-gray-400">‚óè</span>
                        </div>
                    </div>
                    
                    <p class="campaign-card-description" x-text="card.description || 'No description'"></p>
                    
                    <div class="campaign-card-stats">
                        <div class="stat-item">
                            <div class="stat-value" x-text="formatNumber(card.request_count)"></div>
                            <div class="stat-label">Total Requests</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" x-text="formatNumber(card.recent_count)"></div>
                            <div class="stat-label">Last 24h</div>
                        </div>
                    </div>
                    
                    <!-- Tunnel Info -->
                    <div x-show="card.tunnel_requests > 0" class="campaign-card-tunnel">
                        <div class="tunnel-badge">
                            üåç <span x-text="card.tunnel_percentage + '%'"></span> via tunnel
                        </div>
                        <div x-show="card.tunnel_url" class="tunnel-url" x-text="card.tunnel_url"></div>
                    </div>
                    
                    <!-- Top Methods -->
                    <div x-show="card.top_methods && card.top_methods.length > 0" class="campaign-card-methods">
                        <div class="methods-label">Top Methods:</div>
                        <div class="methods-list">
                            <template x-for="method in card.top_methods.slice(0, 3)" :key="method.method">
                                <span class="method-tag" x-text="`${method.method} (${method.count})`"></span>
                            </template>
                        </div>
                    </div>
                    
                    <div class="campaign-card-footer">
                        <div class="campaign-footer-info">
                            <div class="last-activity" x-show="card.latest_request">
                                Last activity: <span x-text="formatTimestamp(card.latest_request)"></span>
                            </div>
                            <div x-show="!card.latest_request" class="text-gray-500">No requests yet</div>
                        </div>
                        <div class="campaign-actions">
                            <button 
                                @click.stop="clearCampaignLogs(card.name)"
                                class="btn-action btn-clear"
                                title="Clear logs for this campaign"
                                :disabled="card.request_count === 0"
                            >
                                üóëÔ∏è Clear
                            </button>
                            <button 
                                @click.stop="deleteCampaign(card.id, card.name)"
                                class="btn-action btn-delete"
                                title="Delete campaign and all logs"
                                :disabled="card.request_count === 0"
                            >
                                ‚ùå Delete
                            </button>
                        </div>
                    </div>
                </div>
            </template>
        </div>
        
        <!-- Campaign Cards Pagination -->
        <div x-show="campaignCardsPagination.totalPages > 1" class="campaign-cards-pagination">
            <button 
                @click="loadCampaignCards(campaignCardsPagination.currentPage - 1)" 
                :disabled="campaignCardsPagination.currentPage === 1 || loadingCampaignCards"
                class="btn btn-outline"
            >
                ‚Üê Previous
            </button>
            
            <span class="pagination-info">
                Page <span x-text="campaignCardsPagination.currentPage"></span> of 
                <span x-text="campaignCardsPagination.totalPages"></span>
            </span>
            
            <button 
                @click="loadCampaignCards(campaignCardsPagination.currentPage + 1)" 
                :disabled="campaignCardsPagination.currentPage >= campaignCardsPagination.totalPages || loadingCampaignCards"
                class="btn btn-outline"
            >
                Next ‚Üí
            </button>
        </div>
        
        <!-- Loading State for Campaign Cards -->
        <div x-show="loadingCampaignCards" class="loading-container">
            <div class="loading-spinner"></div>
            <span>Loading campaigns...</span>
        </div>
        
        <!-- Empty State for Campaign Cards -->
        <div x-show="!loadingCampaignCards && campaignCards.length === 0" class="empty-state">
            <div class="text-6xl mb-4">üìä</div>
            <h3 class="text-lg font-semibold text-gray-900 mb-2">No campaigns found</h3>
            <p class="text-gray-600">Start redirecting traffic to create your first campaign.</p>
        </div>
        
        <!-- Show More Button -->
        <div x-show="campaignCards.length < campaignCardsPagination.totalItems && !loadingCampaignCards" class="text-center mt-4">
            <button 
                @click="loadMoreCampaignCards()"
                class="btn btn-outline"
            >
                See More Campaigns
            </button>
        </div>
    </section>

    <!-- Error Alert -->
    <div x-show="errorState.hasError" x-transition class="alert alert-error">
        <div class="flex-1">
            <strong>‚ö†Ô∏è Error:</strong>
            <span x-text="errorState.message"></span>
        </div>
        <button @click="clearError()" class="alert-close" aria-label="Close error">
            <span aria-hidden="true">√ó</span>
        </button>
    </div>

    <!-- Success Alert -->
    <div x-show="successMessage" x-transition class="alert alert-success">
        <div class="flex-1">
            <strong>‚úÖ Success:</strong>
            <span x-text="successMessage"></span>
        </div>
        <button @click="successMessage = null" class="alert-close" aria-label="Close success message">
            <span aria-hidden="true">√ó</span>
        </button>
    </div>

    <!-- Filters Card -->
    <div class="card" data-animate>
        <div class="card-header">
            <h2 class="card-title">
                <span>üîç</span>
                <span>Filters & Controls</span>
            </h2>
        </div>
        <div class="card-content">
            <form @submit.prevent="handleFilterSubmit()" class="space-y-4">
                <div class="form-grid">
                    <div class="form-group">
                        <label for="campaign-filter" class="form-label">Campaign</label>
                        <select 
                            id="campaign-filter" 
                            x-model="filters.campaign" 
                            @change="debounceFilter()"
                            class="form-select"
                        >
                            <option value="">All Campaigns</option>
                            <template x-for="campaign in campaigns" :key="campaign.id || campaign.name">
                                <option :value="campaign.name" x-text="campaign.name"></option>
                            </template>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label for="method-filter" class="form-label">HTTP Method</label>
                        <select 
                            id="method-filter" 
                            x-model="filters.method" 
                            @change="debounceFilter()"
                            class="form-select"
                        >
                            <option value="">All Methods</option>
                            <option value="GET">GET</option>
                            <option value="POST">POST</option>
                            <option value="PUT">PUT</option>
                            <option value="DELETE">DELETE</option>
                            <option value="PATCH">PATCH</option>
                            <option value="HEAD">HEAD</option>
                            <option value="OPTIONS">OPTIONS</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label for="ip-filter" class="form-label">IP Address</label>
                        <input 
                            type="text" 
                            id="ip-filter" 
                            x-model="filters.ip" 
                            @input="debounceFilter()" 
                            placeholder="Filter by IP address..."
                            class="form-input"
                            data-search
                        >
                    </div>
                    
                    <div class="form-group">
                        <label for="ua-filter" class="form-label">User Agent</label>
                        <input 
                            type="text" 
                            id="ua-filter" 
                            x-model="filters.userAgent" 
                            @input="debounceFilter()" 
                            placeholder="Filter by user agent..."
                            class="form-input"
                        >
                    </div>
                    
                    <div class="form-group">
                        <label for="path-filter" class="form-label">Request Path</label>
                        <input 
                            type="text" 
                            id="path-filter" 
                            x-model="filters.path" 
                            @input="debounceFilter()" 
                            placeholder="Filter by request path..."
                            class="form-input"
                        >
                    </div>
                    
                    <div class="form-group">
                        <label for="time-range" class="form-label">Time Range</label>
                        <select 
                            id="time-range" 
                            x-model="filters.timeRange" 
                            @change="handleTimeRangeChange()"
                            class="form-select"
                        >
                            <option value="">All Time</option>
                            <option value="1h">Last Hour</option>
                            <option value="6h">Last 6 Hours</option>
                            <option value="24h">Last 24 Hours</option>
                            <option value="7d">Last 7 Days</option>
                            <option value="30d">Last 30 Days</option>
                        </select>
                    </div>
                </div>
                
                <div class="btn-group">
                    <button 
                        type="button"
                        @click="exportData('csv')" 
                        :disabled="loading"
                        class="btn btn-outline"
                    >
                        <span>üìä</span>
                        <span>Export CSV</span>
                    </button>
                    
                    <button 
                        type="button"
                        @click="exportData('jsonl')" 
                        :disabled="loading"
                        class="btn btn-outline"
                    >
                        <span>üìÑ</span>
                        <span>Export JSONL</span>
                    </button>
                    
                    <button 
                        type="button"
                        @click="clearAllFilters()" 
                        :disabled="loading"
                        class="btn btn-outline"
                        data-clear-filters
                    >
                        <span>üîÑ</span>
                        <span>Clear Filters</span>
                    </button>
                    
                    <button 
                        type="button"
                        @click="toggleAutoRefresh()" 
                        :class="autoRefresh.enabled ? 'btn btn-primary' : 'btn btn-outline'"
                        :disabled="loading"
                    >
                        <span x-show="autoRefresh.enabled">‚è∏Ô∏è</span>
                        <span x-show="!autoRefresh.enabled">‚ñ∂Ô∏è</span>
                        <span x-text="autoRefresh.enabled ? 'Pause Refresh' : 'Auto Refresh'"></span>
                    </button>
                    
                    <button 
                        type="button"
                        @click="refreshData()" 
                        :disabled="loading"
                        class="btn btn-outline"
                        data-refresh
                    >
                        <div x-show="loading" class="loading-spinner"></div>
                        <span x-show="!loading">üîÑ</span>
                        <span x-text="loading ? 'Loading...' : 'Refresh'"></span>
                    </button>
                </div>
            </form>
        </div>
    </div>

    <!-- Loading State -->
    <div x-show="loading && logs.length === 0" class="loading-container">
        <div class="loading-spinner"></div>
        <span>Loading dashboard data...</span>
    </div>

    <!-- Logs Table -->
    <div x-show="!loading || logs.length > 0" class="card" data-animate>
        <div class="card-header">
            <div class="flex justify-between items-center w-full">
                <h2 class="card-title">
                    <span>üìã</span>
                    <span>Request Logs</span>
                </h2>
                <div class="text-sm text-gray-600">
                    <span x-text="`Showing ${logs.length} of ${totalLogs} requests`"></span>
                    <span x-show="lastUpdated" class="ml-2">
                        (Updated: <span x-text="lastUpdated"></span>)
                    </span>
                </div>
            </div>
        </div>
        
        <div class="table-container">
            <table class="table">
                <thead>
                    <tr>
                        <th scope="col">Timestamp</th>
                        <th scope="col">IP Address</th>
                        <th scope="col">Method</th>
                        <th scope="col">Path</th>
                        <th scope="col">User Agent</th>
                        <th scope="col">Campaign</th>
                        <th scope="col">Source</th>
                        <th scope="col">Actions</th>
                    </tr>
                </thead>
                <tbody>
                    <template x-for="log in logs" :key="log.id">
                        <tr>
                            <td>
                                <time :datetime="log.timestamp" x-text="formatTimestamp(log.timestamp)"></time>
                            </td>
                            <td x-text="getDisplayIP(log)"></td>
                            <td>
                                <span 
                                    class="method-badge" 
                                    :class="`method-${getMethodClass(log.method)}`"
                                    x-text="log.method || 'UNKNOWN'"
                                ></span>
                            </td>
                            <td>
                                <span 
                                    class="truncate" 
                                    :title="log.path"
                                    x-text="log.path || '/'"
                                ></span>
                            </td>
                            <td>
                                <span 
                                    class="truncate" 
                                    :title="log.user_agent"
                                    x-text="truncateText(log.user_agent || 'Unknown', 30)"
                                ></span>
                            </td>
                            <td>
                                <span 
                                    class="campaign-badge text-xs" 
                                    x-text="log.campaign || 'default'"
                                ></span>
                            </td>
                            <td>
                                <div class="source-indicator">
                                    <span 
                                        x-show="log.via_tunnel" 
                                        class="tunnel-badge-small" 
                                        title="Request came through tunnel"
                                    >
                                        üåç Tunnel
                                    </span>
                                    <span 
                                        x-show="!log.via_tunnel" 
                                        class="direct-badge-small"
                                        title="Direct request"
                                    >
                                        üîó Direct
                                    </span>
                                </div>
                            </td>
                            <td>
                                <button 
                                    @click="openLogDetails(log)" 
                                    class="btn btn-outline btn-sm"
                                    :aria-label="`View details for log ${log.id}`"
                                >
                                    <span>üëÅÔ∏è</span>
                                    <span class="sr-only">View Details</span>
                                </button>
                            </td>
                        </tr>
                    </template>
                </tbody>
            </table>
        </div>
        
        <!-- Empty State -->
        <div x-show="logs.length === 0 && !loading" class="text-center py-12">
            <div class="text-6xl mb-4">üì≠</div>
            <h3 class="text-lg font-semibold text-gray-900 mb-2">No logs found</h3>
            <p class="text-gray-600 mb-4">
                <span x-show="hasActiveFilters()">No logs match your current filters.</span>
                <span x-show="!hasActiveFilters()">No requests have been logged yet.</span>
            </p>
            <button 
                x-show="hasActiveFilters()" 
                @click="clearAllFilters()"
                class="btn btn-outline"
            >
                Clear Filters
            </button>
        </div>
        
        <!-- Pagination -->
        <div x-show="pagination.totalPages > 1" class="flex justify-center items-center gap-4 p-4 border-t">
            <button 
                @click="goToPage(pagination.currentPage - 1)" 
                :disabled="pagination.currentPage === 1 || loading"
                class="btn btn-outline"
            >
                ‚Üê Previous
            </button>
            
            <span class="text-sm text-gray-600">
                Page <span x-text="pagination.currentPage"></span> of 
                <span x-text="pagination.totalPages"></span>
            </span>
            
            <button 
                @click="goToPage(pagination.currentPage + 1)" 
                :disabled="pagination.currentPage >= pagination.totalPages || loading"
                class="btn btn-outline"
            >
                Next ‚Üí
            </button>
        </div>
    </div>

    <!-- Log Detail Modal -->
    <div 
        x-show="selectedLog" 
        x-transition:enter="transition ease-out duration-300"
        x-transition:enter-start="opacity-0"
        x-transition:enter-end="opacity-100"
        x-transition:leave="transition ease-in duration-200"
        x-transition:leave-start="opacity-100"
        x-transition:leave-end="opacity-0"
        @click="closeLogDetails()"
        @keydown.escape="closeLogDetails()"
        class="modal-overlay"
        style="display: none;"
    >
        <div 
            @click.stop
            class="modal-content"
            x-transition:enter="transition ease-out duration-300"
            x-transition:enter-start="opacity-0 transform scale-95"
            x-transition:enter-end="opacity-100 transform scale-100"
            x-transition:leave="transition ease-in duration-200"
            x-transition:leave-start="opacity-100 transform scale-100"
            x-transition:leave-end="opacity-0 transform scale-95"
        >
            <div class="modal-header">
                <h3 class="modal-title">üìù Log Details</h3>
                <button @click="closeLogDetails()" class="modal-close" aria-label="Close modal">
                    <span aria-hidden="true">√ó</span>
                </button>
            </div>
            
            <div class="modal-body" x-show="selectedLog">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                    <div>
                        <h4 class="font-semibold text-gray-900 mb-2">Timestamp</h4>
                        <p x-text="formatTimestamp(selectedLog?.timestamp, true)"></p>
                    </div>
                    
                    <div>
                        <h4 class="font-semibold text-gray-900 mb-2">IP Address</h4>
                        <p x-text="getDisplayIP(selectedLog)"></p>
                    </div>
                    
                    <div>
                        <h4 class="font-semibold text-gray-900 mb-2">HTTP Method</h4>
                        <span 
                            class="method-badge" 
                            :class="`method-${getMethodClass(selectedLog?.method)}`"
                            x-text="selectedLog?.method || 'UNKNOWN'"
                        ></span>
                    </div>
                    
                    <div>
                        <h4 class="font-semibold text-gray-900 mb-2">Campaign</h4>
                        <span class="campaign-badge text-sm" x-text="selectedLog?.campaign || 'default'"></span>
                    </div>
                </div>
                
                <div class="space-y-4">
                    <div>
                        <h4 class="font-semibold text-gray-900 mb-2">Full URL</h4>
                        <p class="break-all bg-gray-50 p-3 rounded text-sm font-mono" x-text="selectedLog?.url"></p>
                    </div>
                    
                    <div x-show="selectedLog?.referer">
                        <h4 class="font-semibold text-gray-900 mb-2">Referer</h4>
                        <p class="break-all bg-gray-50 p-3 rounded text-sm font-mono" x-text="selectedLog?.referer"></p>
                    </div>
                    
                    <div x-show="selectedLog?.user_agent">
                        <h4 class="font-semibold text-gray-900 mb-2">User Agent</h4>
                        <p class="break-all bg-gray-50 p-3 rounded text-sm font-mono" x-text="selectedLog?.user_agent"></p>
                    </div>
                    
                    <div x-show="selectedLog?.headers && Object.keys(selectedLog.headers).length > 0">
                        <h4 class="font-semibold text-gray-900 mb-2">Request Headers</h4>
                        <pre class="bg-gray-50 p-4 rounded text-sm font-mono overflow-x-auto" x-text="formatJSON(selectedLog?.headers)"></pre>
                    </div>
                    
                    <div x-show="selectedLog?.query">
                        <h4 class="font-semibold text-gray-900 mb-2">Query Parameters</h4>
                        <p class="break-all bg-gray-50 p-3 rounded text-sm font-mono" x-text="selectedLog?.query"></p>
                    </div>
                    
                    <div x-show="selectedLog?.response_time_ms">
                        <h4 class="font-semibold text-gray-900 mb-2">Response Time</h4>
                        <p><span x-text="selectedLog?.response_time_ms"></span> ms</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Confirmation Modal -->
    <div 
        x-show="confirmModal.show" 
        x-transition:enter="transition ease-out duration-300"
        x-transition:enter-start="opacity-0"
        x-transition:enter-end="opacity-100"
        x-transition:leave="transition ease-in duration-200"
        x-transition:leave-start="opacity-100"
        x-transition:leave-end="opacity-0"
        @click="confirmModal.show = false"
        @keydown.escape="confirmModal.show = false"
        class="modal-overlay"
        style="display: none;"
    >
        <div 
            @click.stop
            class="modal-content"
            :class="{
                'border-red-500': confirmModal.type === 'danger',
                'border-yellow-500': confirmModal.type === 'warning',
                'border-blue-500': confirmModal.type === 'info'
            }"
            x-transition:enter="transition ease-out duration-300"
            x-transition:enter-start="opacity-0 transform scale-95"
            x-transition:enter-end="opacity-100 transform scale-100"
            x-transition:leave="transition ease-in duration-200"
            x-transition:leave-start="opacity-100 transform scale-100"
            x-transition:leave-end="opacity-0 transform scale-95"
        >
            <div class="modal-header">
                <h3 class="modal-title flex items-center">
                    <span class="mr-2 text-xl" x-text="confirmModal.icon"></span>
                    <span x-text="confirmModal.title"></span>
                </h3>
                <button @click="confirmModal.show = false" class="modal-close" aria-label="Close modal">
                    <span aria-hidden="true">√ó</span>
                </button>
            </div>
            
            <div class="modal-body">
                <p class="text-gray-700 leading-relaxed" x-text="confirmModal.message"></p>
            </div>
            
            <div class="modal-footer">
                <button 
                    @click="confirmModal.show = false" 
                    class="btn btn-outline mr-3"
                >
                    Cancel
                </button>
                <button 
                    @click="confirmModal.onConfirm && confirmModal.onConfirm(); confirmModal.show = false" 
                    class="btn"
                    :class="{
                        'btn-danger': confirmModal.type === 'danger',
                        'btn-warning': confirmModal.type === 'warning',
                        'btn-primary': confirmModal.type === 'info' || confirmModal.type === 'default'
                    }"
                    x-text="confirmModal.confirmText"
                >
                </button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
/**
 * Modern Dashboard Application
 * Built with Alpine.js 3.x and ES6+ features
 * 
 * @author Dashboard Team
 * @version 2.0.0
 */

/**
 * Dashboard application state and methods
 * @returns {Object} Alpine.js data object
 */
function dashboardApp() {
    return {
        // ==================== STATE ====================
        
        /** @type {Array<Object>} Current log entries */
        logs: [],
        
        /** @type {Array<Object>} Available campaigns */
        campaigns: [],
        
        /** @type {Array<Object>} Campaign cards with metadata */
        campaignCards: [],
        
        /** @type {boolean} Loading state for campaign cards */
        loadingCampaignCards: false,
        
        /** @type {Array<Object>} Active servers */
        servers: [],
        
        /** @type {Object|null} Server statistics */
        serverStats: null,
        
        /** @type {boolean} Loading state for servers */
        loadingServers: false,
        
        /** @type {Object} Dashboard statistics */
        stats: {
            totalRequests: 0,
            recentRequests: 0,
            methodCount: 0,
            topUserAgents: {}
        },
        
        /** @type {Object|null} Currently selected log for detail view */
        selectedLog: null,
        
        /** @type {boolean} Loading state indicator */
        loading: false,
        
        /** @type {Object} Error state management */
        errorState: {
            hasError: false,
            message: '',
            code: null
        },
        
        /** @type {string|null} Success message */
        successMessage: null,
        
        /** @type {string|null} Last update timestamp */
        lastUpdated: null,
        
        /** @type {Object} Confirmation modal state */
        confirmModal: {
            show: false,
            title: '',
            message: '',
            icon: '‚ö†Ô∏è',
            type: 'default',
            confirmText: 'Confirm',
            onConfirm: null
        },
        
        // ==================== FILTERS ====================
        
        /** @type {Object} Current filter values */
        filters: {
            campaign: '',
            method: '',
            ip: '',
            userAgent: '',
            path: '',
            timeRange: '',
            startTime: '',
            endTime: ''
        },
        
        // ==================== PAGINATION ====================
        
        /** @type {Object} Pagination state */
        pagination: {
            currentPage: 1,
            totalPages: 1,
            perPage: 50,
            totalItems: 0
        },
        
        /** @type {Object} Campaign cards pagination state */
        campaignCardsPagination: {
            currentPage: 1,
            totalPages: 1,
            perPage: 20,
            totalItems: 0
        },
        
        // ==================== AUTO REFRESH ====================
        
        /** @type {Object} Auto refresh configuration */
        autoRefresh: {
            enabled: true,
            interval: 5000, // 5 seconds - faster updates
            timerId: null
        },
        
        // ==================== REAL-TIME UPDATES ====================
        
        /** @type {Object} Real-time update configuration */
        realTime: {
            websocket: null,
            reconnectAttempts: 0,
            maxReconnectAttempts: 5,
            reconnectDelay: 3000,
            heartbeatInterval: null
        },
        
        // ==================== INTERNAL STATE ====================
        
        /** @type {number|null} Debounce timer for filters */
        _debounceTimer: null,
        
        /** @type {AbortController|null} Current fetch abort controller */
        _abortController: null,
        
        // ==================== INITIALIZATION ====================
        
        /**
         * Initialize the dashboard application
         */
        async initialize() {
            try {
                console.info('üöÄ Initializing Redirector Dashboard v2.0.0');
                
                // Initialize data from server-side rendering
                await this._initializeServerData();
                
                // Set up event listeners
                this._setupEventListeners();
                
                // Load initial data
                await this.loadInitialData();
                
                // Load campaign cards
                await this.loadCampaignCards();
                
                // Initialize real-time updates
                this._initializeRealTime();
                
                // Start auto refresh if enabled (fallback for WebSocket failures)
                if (this.autoRefresh.enabled) {
                    this._startAutoRefresh();
                }
                
                console.info('‚úÖ Dashboard initialized successfully');
                
            } catch (error) {
                console.error('‚ùå Failed to initialize dashboard:', error);
                this._handleError('Failed to initialize dashboard', error);
            }
        },
        
        /**
         * Initialize data from server-side rendering
         * @private
         */
        async _initializeServerData() {
            try {
                // Safely parse server-side data with fallbacks
                this.logs = this._parseServerData({{ logs | tojson | safe }}, []);
                this.campaigns = this._parseServerData({{ campaigns | tojson | safe }}, []);
                const serverStats = this._parseServerData({{ stats | tojson | safe }}, {});
                
                this.stats = {
                    totalRequests: serverStats.total_requests || 0,
                    recentRequests: serverStats.recent_requests || 0,
                    methodCount: serverStats.methods ? Object.keys(serverStats.methods).length : 0,
                    topUserAgents: serverStats.top_user_agents || {}
                };
                
                this.pagination.totalItems = this.logs.length;
                this.pagination.totalPages = Math.ceil(this.pagination.totalItems / this.pagination.perPage) || 1;
                
            } catch (error) {
                console.warn('‚ö†Ô∏è Failed to parse server data, using defaults:', error);
                this.logs = [];
                this.campaigns = [];
                this.stats = { totalRequests: 0, recentRequests: 0, methodCount: 0, topUserAgents: {} };
            }
        },
        
        /**
         * Parse server data safely
         * @private
         * @param {any} data - Data to parse
         * @param {any} fallback - Fallback value
         * @returns {any} Parsed data or fallback
         */
        _parseServerData(data, fallback) {
            if (data === null || data === undefined) return fallback;
            return Array.isArray(data) || typeof data === 'object' ? data : fallback;
        },
        
        /**
         * Set up global event listeners
         * @private
         */
        _setupEventListeners() {
            // Handle page unload cleanup
            window.addEventListener('beforeunload', () => {
                this._cleanup();
            });
            
            // Handle keyboard shortcuts
            document.addEventListener('keydown', (event) => {
                if (event.key === 'Escape' && this.selectedLog) {
                    this.closeLogDetails();
                }
                
                // Ctrl/Cmd + R for refresh
                if ((event.ctrlKey || event.metaKey) && event.key === 'r') {
                    event.preventDefault();
                    this.refreshData();
                }
            });
            
            // Handle visibility change for auto-refresh
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    this._pauseAutoRefresh();
                } else if (this.autoRefresh.enabled) {
                    this._startAutoRefresh();
                }
            });
        },
        
        // ==================== DATA LOADING ====================
        
        /**
         * Load initial dashboard data
         */
        async loadInitialData() {
            this.loading = true;
            this.clearError();
            
            try {
                await Promise.all([
                    this._fetchLogs(),
                    this._fetchStats(),
                    this._fetchServers(),
                    this._fetchServerStats()
                ]);
                
                this.lastUpdated = this.formatTimestamp(new Date().toISOString());
                
            } catch (error) {
                this._handleError('Failed to load dashboard data', error);
            } finally {
                this.loading = false;
            }
        },
        
        /**
         * Refresh all dashboard data
         */
        async refreshData() {
            await this.loadInitialData();
            this.showSuccessMessage('Dashboard data refreshed successfully');
        },
        
        /**
         * Fetch logs from API
         * @private
         */
        async _fetchLogs() {
            // Cancel any existing request
            if (this._abortController) {
                this._abortController.abort();
            }
            
            this._abortController = new AbortController();
            
            const params = new URLSearchParams({
                page: this.pagination.currentPage.toString(),
                per_page: this.pagination.perPage.toString()
            });
            
            // Add filters to params
            this._addFiltersToParams(params);
            
            const response = await fetch(`/api/logs?${params}`, {
                signal: this._abortController.signal,
                headers: {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json'
                }
            });
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const data = await response.json();
            
            this.logs = Array.isArray(data.logs) ? data.logs : [];
            this.pagination.totalItems = typeof data.total === 'number' ? data.total : 0;
            this.pagination.totalPages = typeof data.pages === 'number' ? data.pages : 1;
            
            console.info(`üìä Fetched ${this.logs.length} logs (page ${this.pagination.currentPage})`);
        },
        
        /**
         * Fetch statistics from API
         * @private
         */
        async _fetchStats() {
            const params = new URLSearchParams();
            
            if (this.filters.campaign) {
                params.append('campaign', this.filters.campaign);
            }
            
            const response = await fetch(`/api/stats?${params}`, {
                headers: {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json'
                }
            });
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const data = await response.json();
            
            this.stats = {
                totalRequests: data.total_requests || 0,
                recentRequests: data.recent_requests || 0,
                methodCount: data.methods ? Object.keys(data.methods).length : 0,
                topUserAgents: data.top_user_agents || {}
            };
        },
        
        /**
         * Add current filters to URL params
         * @private
         * @param {URLSearchParams} params - URL search params object
         */
        _addFiltersToParams(params) {
            const filterMap = {
                campaign: 'campaign',
                method: 'method_filter',
                ip: 'ip_filter',
                userAgent: 'ua_filter',
                path: 'path_filter',
                startTime: 'start_time',
                endTime: 'end_time'
            };
            
            Object.entries(filterMap).forEach(([filterKey, paramKey]) => {
                const value = this.filters[filterKey];
                if (value && value.trim()) {
                    params.append(paramKey, value.trim());
                }
            });
        },
        
        /**
         * Fetch server status data
         * @private
         */
        async _fetchServers() {
            try {
                const response = await fetch('/api/servers', {
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const servers = await response.json();
                this.servers = Array.isArray(servers) ? servers : [];
                
                console.info(`üñ•Ô∏è Fetched ${this.servers.length} servers`);
            } catch (error) {
                console.warn('‚ö†Ô∏è Failed to fetch servers:', error);
                this.servers = []; // Fail gracefully
            }
        },
        
        /**
         * Fetch server statistics
         * @private
         */
        async _fetchServerStats() {
            try {
                const response = await fetch('/api/servers/stats', {
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const stats = await response.json();
                this.serverStats = stats;
                
                console.info('üìä Server stats updated:', stats);
            } catch (error) {
                console.warn('‚ö†Ô∏è Failed to fetch server stats:', error);
                this.serverStats = null; // Fail gracefully
            }
        },
        
        // ==================== SERVER MANAGEMENT ====================
        
        /**
         * Refresh server data
         */
        async refreshServers() {
            this.loadingServers = true;
            try {
                await Promise.all([
                    this._fetchServers(),
                    this._fetchServerStats()
                ]);
                console.info('üîÑ Server data refreshed');
            } catch (error) {
                this._handleError('Failed to refresh server data', error);
            } finally {
                this.loadingServers = false;
            }
        },
        
        /**
         * Format relative time (e.g., "5 minutes ago")
         * @param {string} timestamp - ISO timestamp string
         * @returns {string} Relative time string
         */
        formatRelativeTime(timestamp) {
            if (!timestamp) return 'Unknown';
            
            try {
                const date = new Date(timestamp);
                const now = new Date();
                const diffSeconds = Math.floor((now - date) / 1000);
                
                if (diffSeconds < 60) {
                    return 'Just now';
                } else if (diffSeconds < 3600) {
                    const minutes = Math.floor(diffSeconds / 60);
                    return `${minutes} minute${minutes !== 1 ? 's' : ''} ago`;
                } else if (diffSeconds < 86400) {
                    const hours = Math.floor(diffSeconds / 3600);
                    return `${hours} hour${hours !== 1 ? 's' : ''} ago`;
                } else {
                    const days = Math.floor(diffSeconds / 86400);
                    return `${days} day${days !== 1 ? 's' : ''} ago`;
                }
            } catch (error) {
                console.warn('Failed to format relative time:', timestamp, error);
                return 'Unknown';
            }
        },
        
        // ==================== FILTER MANAGEMENT ====================
        
        /**
         * Handle form submission (prevent default)
         */
        handleFilterSubmit() {
            // Form submission is handled by input events
            console.info('Filter form submitted (handled by reactive filters)');
        },
        
        /**
         * Debounced filter application
         */
        debounceFilter() {
            if (this._debounceTimer) {
                clearTimeout(this._debounceTimer);
            }
            
            this._debounceTimer = setTimeout(() => {
                this.applyFilters();
            }, 300);
        },
        
        /**
         * Apply current filters
         */
        async applyFilters() {
            console.info('üîç Applying filters:', this.filters);
            
            this.pagination.currentPage = 1; // Reset to first page
            await this.loadInitialData();
        },
        
        /**
         * Handle time range filter change
         */
        handleTimeRangeChange() {
            const now = new Date();
            let startTime = '';
            
            const timeRangeMap = {
                '1h': 60 * 60 * 1000,
                '6h': 6 * 60 * 60 * 1000,
                '24h': 24 * 60 * 60 * 1000,
                '7d': 7 * 24 * 60 * 60 * 1000,
                '30d': 30 * 24 * 60 * 60 * 1000
            };
            
            if (this.filters.timeRange && timeRangeMap[this.filters.timeRange]) {
                const milliseconds = timeRangeMap[this.filters.timeRange];
                startTime = new Date(now.getTime() - milliseconds).toISOString();
            }
            
            this.filters.startTime = startTime;
            this.filters.endTime = ''; // Clear end time when using preset ranges
            
            this.debounceFilter();
        },
        
        /**
         * Clear all filters
         */
        clearAllFilters() {
            console.info('üßπ Clearing all filters');
            
            this.filters = {
                campaign: '',
                method: '',
                ip: '',
                userAgent: '',
                path: '',
                timeRange: '',
                startTime: '',
                endTime: ''
            };
            
            this.debounceFilter();
        },
        
        /**
         * Check if any filters are currently active
         * @returns {boolean} True if filters are active
         */
        hasActiveFilters() {
            return Object.values(this.filters).some(value => value && value.trim());
        },
        
        // ==================== PAGINATION ====================
        
        /**
         * Navigate to specific page
         * @param {number} page - Page number to navigate to
         */
        async goToPage(page) {
            if (page < 1 || page > this.pagination.totalPages || page === this.pagination.currentPage) {
                return;
            }
            
            console.info(`üìÑ Navigating to page ${page}`);
            
            this.pagination.currentPage = page;
            await this.loadInitialData();
        },
        
        // ==================== EXPORT FUNCTIONALITY ====================
        
        /**
         * Export data in specified format
         * @param {'csv'|'jsonl'} format - Export format
         */
        async exportData(format) {
            try {
                console.info(`üì§ Exporting data as ${format.toUpperCase()}`);
                
                const params = new URLSearchParams();
                this._addFiltersToParams(params);
                
                const url = `/api/logs/export.${format}?${params}`;
                
                // Create temporary download link
                const link = document.createElement('a');
                link.href = url;
                link.download = `redirector_logs_${new Date().toISOString().split('T')[0]}.${format}`;
                link.style.display = 'none';
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                this.showSuccessMessage(`Data exported as ${format.toUpperCase()} successfully`);
                
            } catch (error) {
                console.error(`‚ùå Failed to export ${format}:`, error);
                this._handleError(`Failed to export data as ${format.toUpperCase()}`, error);
            }
        },
        
        // ==================== AUTO REFRESH ====================
        
        /**
         * Toggle auto refresh on/off
         */
        toggleAutoRefresh() {
            this.autoRefresh.enabled = !this.autoRefresh.enabled;
            
            if (this.autoRefresh.enabled) {
                this._startAutoRefresh();
                console.info('üîÑ Auto refresh enabled');
            } else {
                this._pauseAutoRefresh();
                console.info('‚è∏Ô∏è Auto refresh paused');
            }
        },
        
        /**
         * Start auto refresh timer
         * @private
         */
        _startAutoRefresh() {
            this._pauseAutoRefresh(); // Clear any existing timer
            
            if (!this.autoRefresh.enabled) return;
            
            this.autoRefresh.timerId = setInterval(async () => {
                if (!this.loading && !this.selectedLog && !document.hidden) {
                    try {
                        await this.loadInitialData();
                        console.info('üîÑ Auto refresh completed');
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Auto refresh failed:', error);
                    }
                }
            }, this.autoRefresh.interval);
        },
        
        /**
         * Pause auto refresh timer
         * @private
         */
        _pauseAutoRefresh() {
            if (this.autoRefresh.timerId) {
                clearInterval(this.autoRefresh.timerId);
                this.autoRefresh.timerId = null;
            }
        },
        
        // ==================== REAL-TIME UPDATES ====================
        
        /**
         * Initialize real-time WebSocket connection
         * @private
         */
        _initializeRealTime() {
            try {
                // Try to establish WebSocket connection for real-time updates
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/api/ws/logs`;
                
                this._connectWebSocket(wsUrl);
                
            } catch (error) {
                console.warn('‚ö†Ô∏è WebSocket not available, falling back to polling:', error);
                // Auto-refresh will handle updates as fallback
            }
        },
        
        /**
         * Connect to WebSocket
         * @private
         * @param {string} url - WebSocket URL
         */
        _connectWebSocket(url) {
            try {
                this.realTime.websocket = new WebSocket(url);
                
                this.realTime.websocket.onopen = () => {
                    console.info('üîå WebSocket connected - Real-time updates enabled');
                    this.realTime.reconnectAttempts = 0;
                    
                    // Send current filter state to server
                    this._sendWebSocketMessage({
                        type: 'subscribe',
                        filters: this.filters
                    });
                    
                    // Start heartbeat
                    this._startWebSocketHeartbeat();
                };
                
                this.realTime.websocket.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        this._handleWebSocketMessage(data);
                    } catch (error) {
                        console.warn('Failed to parse WebSocket message:', error);
                    }
                };
                
                this.realTime.websocket.onclose = (event) => {
                    console.warn('üîå WebSocket disconnected:', event.code, event.reason);
                    this._handleWebSocketDisconnect();
                };
                
                this.realTime.websocket.onerror = (error) => {
                    console.error('üîå WebSocket error:', error);
                };
                
            } catch (error) {
                console.warn('Failed to create WebSocket connection:', error);
                this._handleWebSocketDisconnect();
            }
        },
        
        /**
         * Handle WebSocket messages
         * @private
         * @param {Object} data - Message data
         */
        _handleWebSocketMessage(data) {
            switch (data.type) {
                case 'new_log':
                    this._handleNewLogEntry(data.log);
                    break;
                    
                case 'stats_update':
                    this._handleStatsUpdate(data.stats);
                    break;
                    
                case 'bulk_update':
                    // Full data refresh via WebSocket
                    if (data.logs) this.logs = data.logs;
                    if (data.stats) this._handleStatsUpdate(data.stats);
                    this.lastUpdated = this.formatTimestamp(new Date().toISOString());
                    console.info('üìä Bulk update received via WebSocket');
                    break;
                    
                case 'pong':
                    // Heartbeat response
                    break;
                    
                default:
                    console.warn('Unknown WebSocket message type:', data.type);
            }
        },
        
        /**
         * Handle new log entry from WebSocket
         * @private
         * @param {Object} log - New log entry
         */
        _handleNewLogEntry(log) {
            // Add new log to the beginning of the list
            this.logs.unshift(log);
            
            // Keep only the latest entries (prevent memory bloat)
            if (this.logs.length > this.pagination.perPage * 2) {
                this.logs = this.logs.slice(0, this.pagination.perPage);
            }
            
            // Update pagination info
            this.pagination.totalItems++;
            
            console.info('üìù New log entry received:', log.id);
            
            // Optional: Show brief notification for new entries
            this._showBriefNotification(`New ${log.method} request from ${this.getDisplayIP(log)}`);
        },
        
        /**
         * Handle stats update from WebSocket
         * @private
         * @param {Object} stats - Updated statistics
         */
        _handleStatsUpdate(stats) {
            this.stats = {
                totalRequests: stats.total_requests || this.stats.totalRequests,
                recentRequests: stats.recent_requests || this.stats.recentRequests,
                methodCount: stats.methods ? Object.keys(stats.methods).length : this.stats.methodCount,
                topUserAgents: stats.top_user_agents || this.stats.topUserAgents
            };
        },
        
        /**
         * Send message to WebSocket
         * @private
         * @param {Object} message - Message to send
         */
        _sendWebSocketMessage(message) {
            if (this.realTime.websocket && this.realTime.websocket.readyState === WebSocket.OPEN) {
                try {
                    this.realTime.websocket.send(JSON.stringify(message));
                } catch (error) {
                    console.warn('Failed to send WebSocket message:', error);
                }
            }
        },
        
        /**
         * Start WebSocket heartbeat
         * @private
         */
        _startWebSocketHeartbeat() {
            this._stopWebSocketHeartbeat();
            
            this.realTime.heartbeatInterval = setInterval(() => {
                this._sendWebSocketMessage({ type: 'ping' });
            }, 30000); // Send ping every 30 seconds
        },
        
        /**
         * Stop WebSocket heartbeat
         * @private
         */
        _stopWebSocketHeartbeat() {
            if (this.realTime.heartbeatInterval) {
                clearInterval(this.realTime.heartbeatInterval);
                this.realTime.heartbeatInterval = null;
            }
        },
        
        /**
         * Handle WebSocket disconnect
         * @private
         */
        _handleWebSocketDisconnect() {
            this._stopWebSocketHeartbeat();
            
            // Attempt to reconnect if under retry limit
            if (this.realTime.reconnectAttempts < this.realTime.maxReconnectAttempts) {
                this.realTime.reconnectAttempts++;
                
                console.info(`üîÑ Attempting WebSocket reconnect (${this.realTime.reconnectAttempts}/${this.realTime.maxReconnectAttempts})`);
                
                setTimeout(() => {
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    const wsUrl = `${protocol}//${window.location.host}/api/ws/logs`;
                    this._connectWebSocket(wsUrl);
                }, this.realTime.reconnectDelay);
                
            } else {
                console.warn('üîå Max WebSocket reconnection attempts reached, using polling fallback');
                
                // Ensure auto-refresh is enabled as fallback
                if (!this.autoRefresh.enabled) {
                    this.autoRefresh.enabled = true;
                    this._startAutoRefresh();
                }
            }
        },
        
        /**
         * Show brief notification (non-intrusive)
         * @private
         * @param {string} message - Notification message
         */
        _showBriefNotification(message) {
            // Create a small, non-intrusive notification
            const notification = document.createElement('div');
            notification.className = 'brief-notification';
            notification.textContent = message;
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: var(--primary-600);
                color: white;
                padding: 8px 16px;
                border-radius: 4px;
                font-size: 0.875rem;
                z-index: 1001;
                opacity: 0;
                transform: translateY(-10px);
                transition: all 0.3s ease;
                pointer-events: none;
            `;
            
            document.body.appendChild(notification);
            
            // Animate in
            requestAnimationFrame(() => {
                notification.style.opacity = '1';
                notification.style.transform = 'translateY(0)';
            });
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateY(-10px)';
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 3000);
        },
        
        // ==================== MODAL MANAGEMENT ====================
        
        /**
         * Open log details modal
         * @param {Object} log - Log entry to display
         */
        openLogDetails(log) {
            console.info('üëÅÔ∏è Opening log details for ID:', log.id);
            
            this.selectedLog = log;
            document.body.style.overflow = 'hidden'; // Prevent background scroll
        },
        
        /**
         * Close log details modal
         */
        closeLogDetails() {
            console.info('‚ùå Closing log details modal');
            
            this.selectedLog = null;
            document.body.style.overflow = ''; // Restore scroll
        },
        
        // ==================== ERROR HANDLING ====================
        
        /**
         * Handle application errors
         * @private
         * @param {string} message - Error message
         * @param {Error} error - Error object
         */
        _handleError(message, error) {
            console.error('‚ùå', message, error);
            
            this.errorState = {
                hasError: true,
                message: message,
                code: error.name || 'UnknownError'
            };
            
            // Auto clear error after 10 seconds
            setTimeout(() => {
                this.clearError();
            }, 10000);
        },
        
        /**
         * Clear current error state
         */
        clearError() {
            this.errorState = {
                hasError: false,
                message: '',
                code: null
            };
        },
        
        /**
         * Show success message
         * @param {string} message - Success message
         */
        showSuccessMessage(message) {
            this.successMessage = message;
            
            // Auto clear success message after 5 seconds
            setTimeout(() => {
                this.successMessage = null;
            }, 5000);
        },
        
        // ==================== UTILITY FUNCTIONS ====================
        
        /**
         * Format number with thousand separators
         * @param {number} num - Number to format
         * @returns {string} Formatted number
         */
        formatNumber(num) {
            if (typeof num !== 'number') return '0';
            return num.toLocaleString();
        },
        
        /**
         * Format timestamp for display
         * @param {string} timestamp - ISO timestamp string
         * @param {boolean} includeSeconds - Include seconds in output
         * @returns {string} Formatted timestamp
         */
        formatTimestamp(timestamp, includeSeconds = false) {
            if (!timestamp) return 'N/A';
            
            try {
                const date = new Date(timestamp);
                if (isNaN(date.getTime())) return 'Invalid Date';
                
                const options = {
                    year: 'numeric',
                    month: 'short',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit'
                };
                
                if (includeSeconds) {
                    options.second = '2-digit';
                }
                
                return date.toLocaleString(undefined, options);
            } catch (error) {
                console.warn('Failed to format timestamp:', timestamp, error);
                return 'Invalid Date';
            }
        },
        
        /**
         * Get display IP address (prefer forwarded IP)
         * @param {Object} log - Log entry
         * @returns {string} IP address
         */
        getDisplayIP(log) {
            if (!log) return 'Unknown';
            return log.x_forwarded_for || log.ip || 'Unknown';
        },
        
        /**
         * Get CSS class for HTTP method
         * @param {string} method - HTTP method
         * @returns {string} CSS class name
         */
        getMethodClass(method) {
            if (!method) return 'unknown';
            return method.toLowerCase();
        },
        
        /**
         * Truncate text to specified length
         * @param {string} text - Text to truncate
         * @param {number} length - Maximum length
         * @returns {string} Truncated text
         */
        truncateText(text, length = 50) {
            if (!text || text.length <= length) return text;
            return text.substring(0, length) + '...';
        },
        
        /**
         * Format JSON for display
         * @param {Object} obj - Object to format
         * @returns {string} Formatted JSON string
         */
        formatJSON(obj) {
            if (!obj) return '';
            try {
                return JSON.stringify(obj, null, 2);
            } catch (error) {
                console.warn('Failed to format JSON:', error);
                return String(obj);
            }
        },
        
        // ==================== CAMPAIGN CARDS ====================
        
        /**
         * Load campaign cards
         * @param {number} page - Page number to load
         */
        async loadCampaignCards(page = 1) {
            this.loadingCampaignCards = true;
            this.clearError();
            
            try {
                const params = new URLSearchParams({
                    page: page.toString(),
                    per_page: this.campaignCardsPagination.perPage.toString()
                });
                
                const response = await fetch(`/api/campaign-cards?${params}`, {
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                this.campaignCards = data.campaign_cards || [];
                this.campaignCardsPagination.currentPage = data.page || 1;
                this.campaignCardsPagination.totalPages = data.pages || 1;
                this.campaignCardsPagination.totalItems = data.total || 0;
                
                console.info(`üìä Loaded ${this.campaignCards.length} campaign cards (page ${this.campaignCardsPagination.currentPage})`);
                
            } catch (error) {
                this._handleError('Failed to load campaign cards', error);
            } finally {
                this.loadingCampaignCards = false;
            }
        },
        
        /**
         * Load more campaign cards (append to existing)
         */
        async loadMoreCampaignCards() {
            if (this.campaignCardsPagination.currentPage >= this.campaignCardsPagination.totalPages) {
                return;
            }
            
            const nextPage = this.campaignCardsPagination.currentPage + 1;
            this.loadingCampaignCards = true;
            
            try {
                const params = new URLSearchParams({
                    page: nextPage.toString(),
                    per_page: this.campaignCardsPagination.perPage.toString()
                });
                
                const response = await fetch(`/api/campaign-cards?${params}`, {
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                // Append new cards to existing ones
                this.campaignCards.push(...(data.campaign_cards || []));
                this.campaignCardsPagination.currentPage = data.page || nextPage;
                this.campaignCardsPagination.totalPages = data.pages || this.campaignCardsPagination.totalPages;
                this.campaignCardsPagination.totalItems = data.total || this.campaignCardsPagination.totalItems;
                
                console.info(`üìä Loaded ${data.campaign_cards?.length || 0} more campaign cards`);
                
            } catch (error) {
                this._handleError('Failed to load more campaign cards', error);
            } finally {
                this.loadingCampaignCards = false;
            }
        },
        
        /**
         * Filter logs by campaign (from campaign card click)
         * @param {string} campaignName - Campaign to filter by
         */
        filterByCampaign(campaignName) {
            console.info(`üéØ Filtering logs by campaign: ${campaignName}`);
            
            this.filters.campaign = campaignName;
            this.debounceFilter();
        },
        
        // ==================== CLEANUP ====================
        
        /**
         * Clean up resources when component is destroyed
         * @private
         */
        _cleanup() {
            console.info('üßπ Cleaning up dashboard resources');
            
            this._pauseAutoRefresh();
            this._stopWebSocketHeartbeat();
            
            // Close WebSocket connection
            if (this.realTime.websocket) {
                this.realTime.websocket.close();
                this.realTime.websocket = null;
            }
            
            if (this._debounceTimer) {
                clearTimeout(this._debounceTimer);
                this._debounceTimer = null;
            }
            
            if (this._abortController) {
                this._abortController.abort();
                this._abortController = null;
            }
            
            document.body.style.overflow = ''; // Restore scroll
        },

        // ==================== DATABASE OPERATIONS ====================

        /**
         * Show confirmation modal
         * @param {Object} options - Modal configuration
         */
        showConfirmModal(options) {
            this.confirmModal = {
                show: true,
                title: options.title,
                message: options.message,
                icon: options.icon || '‚ö†Ô∏è',
                type: options.type || 'default',
                confirmText: options.confirmText || 'Confirm',
                onConfirm: options.onConfirm
            };
        },

        /**
         * Clear all logs from database
         */
        async clearAllLogs() {
            this.showConfirmModal({
                title: 'Clear All Logs',
                message: 'Are you sure you want to clear ALL logs from the database? This will permanently delete all request data from ALL campaigns.',
                icon: 'üóëÔ∏è',
                type: 'danger',
                confirmText: 'Clear All Logs',
                onConfirm: async () => {
                    try {
                        const response = await fetch('/api/logs', {
                            method: 'DELETE',
                            headers: {
                                'Accept': 'application/json',
                                'Content-Type': 'application/json'
                            }
                        });

                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }

                        const result = await response.json();
                        
                        // Show success message
                        this._showSuccessMessage(result.message);
                        
                        // Refresh data
                        await this.loadInitialData();
                        await this.loadCampaignCards();
                        
                        console.info(`‚úÖ ${result.message}`);
                        
                    } catch (error) {
                        this._handleError('Failed to clear logs', error);
                    }
                }
            });
        },

        /**
         * Clear logs for specific campaign
         * @param {string} campaignName - Campaign to clear logs for
         */
        async clearCampaignLogs(campaignName) {
            this.showConfirmModal({
                title: `Clear Campaign Logs`,
                message: `Are you sure you want to clear all logs for campaign "${campaignName}"? This action cannot be undone.`,
                icon: 'üóëÔ∏è',
                type: 'danger',
                confirmText: 'Clear Logs',
                onConfirm: async () => {
                    try {
                        const response = await fetch(`/api/logs?campaign=${encodeURIComponent(campaignName)}`, {
                            method: 'DELETE',
                            headers: {
                                'Accept': 'application/json',
                                'Content-Type': 'application/json'
                            }
                        });

                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }

                        const result = await response.json();
                        
                        // Show success message
                        this._showSuccessMessage(result.message);
                        
                        // Refresh data
                        await this.loadInitialData();
                        await this.loadCampaignCards();
                        
                        console.info(`‚úÖ ${result.message}`);
                        
                    } catch (error) {
                        this._handleError('Failed to clear campaign logs', error);
                    }
                }
            });
        },

        /**
         * Delete campaign and all its logs
         * @param {number} campaignId - Campaign ID to delete
         * @param {string} campaignName - Campaign name for display
         */
        async deleteCampaign(campaignId, campaignName) {
            this.showConfirmModal({
                title: `Delete Campaign`,
                message: `Are you sure you want to DELETE campaign "${campaignName}"? This will permanently delete the campaign and ALL associated logs. This action cannot be undone.`,
                icon: '‚ùå',
                type: 'danger',
                confirmText: 'Delete Campaign',
                onConfirm: async () => {
                    try {
                        const response = await fetch(`/api/campaigns/${campaignId}`, {
                            method: 'DELETE',
                            headers: {
                                'Accept': 'application/json',
                                'Content-Type': 'application/json'
                            }
                        });

                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }

                        const result = await response.json();
                        
                        // Show success message
                        this._showSuccessMessage(result.message);
                        
                        // Clear campaign filter if it was the deleted campaign
                        if (this.filters.campaign === campaignName) {
                            this.filters.campaign = '';
                        }
                        
                        // Refresh data
                        await this.loadInitialData();
                        await this.loadCampaignCards();
                        
                        console.info(`‚úÖ ${result.message}`);
                        
                    } catch (error) {
                        this._handleError('Failed to delete campaign', error);
                    }
                }
            });
        },

        /**
         * Show success message
         * @param {string} message - Success message to display
         * @private
         */
        _showSuccessMessage(message) {
            // Create and show temporary success alert
            const alertDiv = document.createElement('div');
            alertDiv.className = 'alert alert-success fixed top-4 right-4 z-50 max-w-md';
            alertDiv.innerHTML = `
                <div class="flex items-center">
                    <span class="mr-2">‚úÖ</span>
                    <span>${message}</span>
                    <button onclick="this.parentElement.parentElement.remove()" class="ml-auto text-lg">&times;</button>
                </div>
            `;
            
            document.body.appendChild(alertDiv);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (alertDiv.parentElement) {
                    alertDiv.remove();
                }
            }, 5000);
        }
    };
}

// Initialize when Alpine.js is ready
document.addEventListener('alpine:init', () => {
    console.info('üèîÔ∏è Alpine.js initialized for Redirector Dashboard');
});

</script>
{% endblock %}